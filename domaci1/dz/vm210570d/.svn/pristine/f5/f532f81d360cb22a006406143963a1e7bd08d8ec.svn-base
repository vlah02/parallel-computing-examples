#include <math.h>
#include <omp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

const char *red = "\033[1;31m";
const char *green = "\033[1;32m";
const char *blue = "\033[1;36m";
const char *clear = "\033[0m";

int main(int argc, char *argv[]);
double *ccn_compute_points_new(int n);
int i4_min(int i1, int i2);
double *nc_compute_new(int n, double x_min, double x_max, double x[]);
double *nc_compute_new_parallel(int n, double x_min, double x_max, double x[]);
double *nc_compute_new_tasks(int n, double x_min, double x_max, double x[]);
void r8mat_write(char *output_filename, int m, int n, double table[]);
void rescale(double a, double b, int n, double x[], double w[]);
void rule_write(int order, char *filename, double x[], double w[], double r[]);

int areTwoFilesSame(const char *file1, const char *file2) {
  FILE *f1 = fopen(file1, "r");
  FILE *f2 = fopen(file2, "r");

  if (f1 == NULL || f2 == NULL) {
    return 0;
  }

  char byte1, byte2;

  while ((byte1 = fgetc(f1)) != EOF && (byte2 = fgetc(f2)) != EOF) {
    if (byte1 != byte2) {
      fclose(f1);
      fclose(f2);
      return 0;
    }
  }

  if (fgetc(f1) != EOF || fgetc(f2) != EOF) {
    fclose(f1);
    fclose(f2);
    return 0;
  }

  fclose(f1);
  fclose(f2);
  return 1;
}

int areFilesSame(const char *file1, const char *file2) {
  char filename1_r[80];
  char filename1_w[80];
  char filename1_x[80];

  strcpy(filename1_r, file1);
  strcat(filename1_r, "_r.txt");
  strcpy(filename1_w, file1);
  strcat(filename1_w, "_w.txt");
  strcpy(filename1_x, file1);
  strcat(filename1_x, "_x.txt");

  char filename2_r[80];
  char filename2_w[80];
  char filename2_x[80];

  strcpy(filename2_r, file2);
  strcat(filename2_r, "_r.txt");
  strcpy(filename2_w, file2);
  strcat(filename2_w, "_w.txt");
  strcpy(filename2_x, file2);
  strcat(filename2_x, "_x.txt");

  return areTwoFilesSame(filename1_r, filename2_r) &&
         areTwoFilesSame(filename1_w, filename2_w) &&
         areTwoFilesSame(filename1_x, filename2_x);
}

int main(int argc, char *argv[]) {
  double a;
  double b;
  char filename[255];
  int n;
  double *r;
  double *w;
  double *x;
  double x_max;
  double x_min;

  printf("\n");
  printf("CCN_RULE\n");
  printf("  C version\n");
  printf("\n");
  printf("  Compute one of a family of nested Clenshaw Curtis rules\n");
  printf("  for approximating\n");
  printf("    Integral ( -1 <= x <= +1 ) f(x) dx\n");
  printf("  of order N.\n");
  printf("\n");
  printf("  The user specifies N, A, B and FILENAME.\n");
  printf("\n");
  printf("  N is the number of points.\n");
  printf("  A is the left endpoint.\n");
  printf("  B is the right endpoint.\n");
  printf("  FILENAME is used to generate 3 files:\n");
  printf("    filename_w.txt - the weight file\n");
  printf("    filename_x.txt - the abscissa file.\n");
  printf("    filename_r.txt - the region file.\n");

  if (1 < argc) {
    n = atoi(argv[1]);
  } else {
    printf("\n");
    printf("  Enter the value of N (1 or greater)\n");
    scanf("%d", &n);
  }

  if (2 < argc) {
    a = atof(argv[2]);
  } else {
    printf("\n");
    printf("  Enter the left endpoint A:\n");
    scanf("%lf", &a);
  }

  if (3 < argc) {
    b = atof(argv[3]);
  } else {
    printf("\n");
    printf("  Enter the right endpoint B:\n");
    scanf("%lf", &b);
  }

  if (4 < argc) {
    strcpy(filename, argv[4]);
  } else {
    printf("\n");
    printf("  Enter FILENAME, the \"root name\" of the quadrature files.\n");
    scanf("%s", filename);
  }

  printf("\n");
  printf("  N = %d\n", n);
  printf("  A = %g\n", a);
  printf("  B = %g\n", b);
  printf("  FILENAME = \"%s\".\n", filename);

  int cpu_nums[] = {2, 4, 8, 16};

  r = (double *)malloc(2 * sizeof(double));

  double start = omp_get_wtime();

  r[0] = a;
  r[1] = b;

  x = ccn_compute_points_new(n);

  x_min = -1.0;
  x_max = +1.0;
  w = nc_compute_new(n, x_min, x_max, x);

  rescale(a, b, n, x, w);

  double end = omp_get_wtime();

  double seq_elapsed_time = end - start;

  printf("%sElapsed time %lf seconds\n%s", blue, seq_elapsed_time, clear);

  rule_write(n, filename, x, w, r);

  for (int i = 0; i < sizeof(cpu_nums) / sizeof(int); i++) {
    omp_set_num_threads(cpu_nums[i]);
    char str_par[100] = "par_";
    char str_task[100] = "task_";

    printf("%sStart computing for %d cpus\n%s", blue, cpu_nums[i], clear);

    printf("%sComputing for paralelisation\n%s", blue, clear);
    printf("%s=======================================%s\n", blue, clear);
    start = omp_get_wtime();

    r[0] = a;
    r[1] = b;

    x = ccn_compute_points_new(n);

    x_min = -1.0;
    x_max = +1.0;
    w = nc_compute_new_parallel(n, x_min, x_max, x);

    rescale(a, b, n, x, w);

    end = omp_get_wtime();
    double par_elapsed = end - start;

    printf("%sElapsed time %lf seconds\n%s", blue, par_elapsed, clear);
    printf("%sSpeedup = %lf\n%s", blue, seq_elapsed_time / par_elapsed, clear);

    strcat(str_par, filename);
    rule_write(n, str_par, x, w, r);

    if (!areFilesSame(str_par, filename)) {
      printf("%sTEST FAILED\n%s", red, clear);
      exit(1);
    }

    printf("%sComputing for tasks\n%s", blue, clear);
    printf("%s=======================================%s\n", blue, clear);
    double start = omp_get_wtime();

    r[0] = a;
    r[1] = b;

    x = ccn_compute_points_new(n);

    x_min = -1.0;
    x_max = +1.0;
    w = nc_compute_new_parallel(n, x_min, x_max, x);

    rescale(a, b, n, x, w);

    double end = omp_get_wtime();

    double task_ellapsed = end - start;

    printf("%sElapsed time %lf seconds\n%s", blue, task_ellapsed, clear);
    printf("%sSpeedup = %lf\n%s", blue, seq_elapsed_time / task_ellapsed,
           clear);

    strcat(str_task, filename);
    rule_write(n, str_task, x, w, r);

    if (!areFilesSame(str_task, filename)) {
      printf("%sTEST FAILED\n%s", red, clear);
      exit(1);
    }
  }

  printf("%sALL TEST PASSED\n%s", green, clear);

  free(r);
  free(w);
  free(x);

  printf("\n");
  printf("CCN_RULE:\n");
  printf("  Normal end of execution.\n");
  printf("\n");

  return 0;
}

double *ccn_compute_points_new(int n) {
  int d;
  int i;
  int k;
  int m;
  double r8_pi = 3.141592653589793;
  int td;
  int tu;
  double *x;

  x = (double *)malloc(n * sizeof(double));

  if (1 <= n) {
    x[0] = 0.5;
  }

  if (2 <= n) {
    x[1] = 1.0;
  }

  if (3 <= n) {
    x[2] = 0.0;
  }

  m = 3;
  d = 2;

  while (m < n) {
    tu = d + 1;
    td = d - 1;

    k = i4_min(d, n - m);

    for (i = 1; i <= k; i++) {
      if ((i % 2) == 1) {
        x[m + i - 1] = tu / 2.0 / (double)(k);
        tu = tu + 2;
      } else {
        x[m + i - 1] = td / 2.0 / (double)(k);
        td = td - 2;
      }
    }
    m = m + k;
    d = d * 2;
  }

  for (i = 0; i < n; i++) {
    x[i] = cos(x[i] * r8_pi);
  }
  x[0] = 0.0;

  if (2 <= n) {
    x[1] = -1.0;
  }

  if (3 <= n) {
    x[2] = +1.0;
  }

  return x;
}

int i4_min(int i1, int i2) {
  int value;

  if (i1 < i2) {
    value = i1;
  } else {
    value = i2;
  }
  return value;
}

double *nc_compute_new(int n, double x_min, double x_max, double x[]) {
  double *d;
  int i;
  int j;
  int k;
  double *w;
  double yvala;
  double yvalb;

  w = (double *)malloc(n * sizeof(double));
  d = (double *)malloc(n * sizeof(double));

  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
      d[j] = 0.0;
    }
    d[i] = 1.0;

    for (j = 2; j <= n; j++) {
      for (k = j; k <= n; k++) {
        d[n + j - k - 1] = (d[n + j - k - 1 - 1] - d[n + j - k - 1]) /
                           (x[n + 1 - k - 1] - x[n + j - k - 1]);
      }
    }

    for (j = 1; j <= n - 1; j++) {
      for (k = 1; k <= n - j; k++) {
        d[n - k - 1] = d[n - k - 1] - x[n - k - j] * d[n - k];
      }
    }

    yvala = d[n - 1] / (double)(n);
    for (j = n - 2; 0 <= j; j--) {
      yvala = yvala * x_min + d[j] / (double)(j + 1);
    }
    yvala = yvala * x_min;

    yvalb = d[n - 1] / (double)(n);
    for (j = n - 2; 0 <= j; j--) {
      yvalb = yvalb * x_max + d[j] / (double)(j + 1);
    }
    yvalb = yvalb * x_max;

    w[i] = yvalb - yvala;
  }
  free(d);

  return w;
}

double *nc_compute_new_parallel(int n, double x_min, double x_max, double x[]) {
  double *d;
  int i;
  int j;
  int k;
  double *w;
  double yvala;
  double yvalb;

  w = (double *)malloc(n * sizeof(double));

#pragma omp parallel private(j, k, yvala, yvalb, d)
  {
    d = (double *)malloc(n * sizeof(double));

#pragma omp for schedule(guided)
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        d[j] = 0.0;
      }
      d[i] = 1.0;

      for (j = 2; j <= n; j++) {
        for (k = j; k <= n; k++) {
          d[n + j - k - 1] = (d[n + j - k - 1 - 1] - d[n + j - k - 1]) /
                             (x[n + 1 - k - 1] - x[n + j - k - 1]);
        }
      }

      for (j = 1; j <= n - 1; j++) {
        for (k = 1; k <= n - j; k++) {
          d[n - k - 1] = d[n - k - 1] - x[n - k - j] * d[n - k];
        }
      }

      yvala = d[n - 1] / (double)(n);
      for (j = n - 2; 0 <= j; j--) {
        yvala = yvala * x_min + d[j] / (double)(j + 1);
      }
      yvala = yvala * x_min;

      yvalb = d[n - 1] / (double)(n);
      for (j = n - 2; 0 <= j; j--) {
        yvalb = yvalb * x_max + d[j] / (double)(j + 1);
      }
      yvalb = yvalb * x_max;

      w[i] = yvalb - yvala;
    }

    free(d);
  }

  return w;
}

double *nc_compute_new_tasks(int n, double x_min, double x_max, double x[]) {
  double *d;
  double *w = (double *)malloc(n * sizeof(double));
  int j, k;
  double yvala, yvalb;

#pragma omp parallel private(j, k, yvala, yvalb, d)
  {
    d = (double *)malloc(n * sizeof(double));
#pragma omp for
    for (int i = 0; i < n; i++) {
#pragma omp task shared(d, w)
      {
        for (int j = 0; j < n; j++) d[j] = 0.0;
        d[i] = 1.0;

        for (int j = 2; j <= n; j++) {
          for (int k = j; k <= n; k++)
            d[n + j - k - 1] = (d[n + j - k - 1 - 1] - d[n + j - k - 1]) /
                               (x[n + 1 - k - 1] - x[n + j - k - 1]);
        }

        for (int j = 1; j <= n - 1; j++) {
          for (int k = 1; k <= n - j; k++)
            d[n - k - 1] = d[n - k - 1] - x[n - k - j] * d[n - k];
        }

        double yvala = d[n - 1] / (double)(n);
        for (int j = n - 2; 0 <= j; j--)
          yvala = yvala * x_min + d[j] / (double)(j + 1);
        yvala = yvala * x_min;

        double yvalb = d[n - 1] / (double)(n);
        for (int j = n - 2; 0 <= j; j--)
          yvalb = yvalb * x_max + d[j] / (double)(j + 1);
        yvalb = yvalb * x_max;

        w[i] = yvalb - yvala;
      }
    }
#pragma omp taskwait
    free(d);
  }
  return w;
}

void r8mat_write(char *output_filename, int m, int n, double table[]) {
  int i;
  int j;
  FILE *output;

  output = fopen(output_filename, "wt");

  if (!output) {
    fprintf(stderr, "\n");
    fprintf(stderr, "R8MAT_WRITE - Fatal error!\n");
    fprintf(stderr, "  Could not open the output file.\n");
    exit(1);
  }

  for (j = 0; j < n; j++) {
    for (i = 0; i < m; i++) {
      fprintf(output, "  %24.16g", table[i + j * m]);
    }
    fprintf(output, "\n");
  }

  fclose(output);

  return;
}

void rescale(double a, double b, int n, double x[], double w[]) {
  int i;

  for (i = 0; i < n; i++) {
    x[i] = ((a + b) + (b - a) * x[i]) / 2.0;
  }
  for (i = 0; i < n; i++) {
    w[i] = (b - a) * w[i] / 2.0;
  }
  return;
}

// void rescale(double a, double b, int n, double x[], double w[]) {
//   int i;
// #pragma omp parallel for private(i) schedule(guided, 4)
//   for (i = 0; i < n; i++) {
//     x[i] = ((a + b) + (b - a) * x[i]) / 2.0;
//     w[i] = (b - a) * w[i] / 2.0;
//   }
// }

void rule_write(int order, char *filename, double x[], double w[], double r[]) {
  char filename_r[80];
  char filename_w[80];
  char filename_x[80];

  strcpy(filename_r, filename);
  strcat(filename_r, "_r.txt");
  strcpy(filename_w, filename);
  strcat(filename_w, "_w.txt");
  strcpy(filename_x, filename);
  strcat(filename_x, "_x.txt");

  printf("\n");
  printf("  Creating quadrature files.\n");
  printf("\n");
  printf("  Root file name is     \"%s\".\n", filename);
  printf("\n");
  printf("  Weight file will be   \"%s\".\n", filename_w);
  printf("  Abscissa file will be \"%s\".\n", filename_x);
  printf("  Region file will be   \"%s\".\n", filename_r);

  r8mat_write(filename_w, 1, order, w);
  r8mat_write(filename_x, 1, order, x);
  r8mat_write(filename_r, 1, 2, r);

  return;
}
