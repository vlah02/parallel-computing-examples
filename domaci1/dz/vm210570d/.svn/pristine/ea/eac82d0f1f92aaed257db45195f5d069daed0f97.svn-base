#include <math.h>
#include <omp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strings.h>
#include <sys/time.h>
#include <unistd.h>

#include "args.h"
#include "model.h"

const char *red = "\033[1;31m";
const char *green = "\033[1;32m";
const char *blue = "\033[1;36m";
const char *clear = "\033[0m";

int areFilesSame(const char *file1, const char *file2) {
  FILE *f1 = fopen(file1, "r");
  FILE *f2 = fopen(file2, "r");

  if (f1 == NULL || f2 == NULL) {
    return 0;
  }

  char byte1, byte2;

  while ((byte1 = fgetc(f1)) != EOF && (byte2 = fgetc(f2)) != EOF) {
    if (byte1 != byte2) {
      fclose(f1);
      fclose(f2);
      return 0;
    }
  }

  if (fgetc(f1) != EOF || fgetc(f2) != EOF) {
    fclose(f1);
    fclose(f2);
    return 0;
  }

  fclose(f1);
  fclose(f2);
  return 1;
}

int main(int argc, char **argv) {
  struct pb_TimerSet timers;
  struct pb_Parameters *params;
  int rf, k, nbins, npd, npr;
  float *binb, w;
  long long *DD, *RRS, *DRS;
  size_t memsize;
  struct cartesian *data, *random;
  FILE *outfile;

  pb_InitializeTimerSet(&timers);
  params = pb_ReadParameters(&argc, argv);

  options args;
  parse_args(argc, argv, &args);

  pb_SwitchToTimer(&timers, pb_TimerID_COMPUTE);
  nbins = (int)floor(bins_per_dec * (log10(max_arcmin) - log10(min_arcmin)));
  memsize = (nbins + 2) * sizeof(long long);

  // memory for bin boundaries
  binb = (float *)malloc((nbins + 1) * sizeof(float));
  if (binb == NULL) {
    fprintf(stderr, "Unable to allocate memory\n");
    exit(-1);
  }
  for (k = 0; k < nbins + 1; k++) {
    binb[k] =
        cos(pow(10, log10(min_arcmin) + k * 1.0 / bins_per_dec) / 60.0 * D2R);
  }

  // memory for DD
  DD = (long long *)malloc(memsize);
  if (DD == NULL) {
    fprintf(stderr, "Unable to allocate memory\n");
    exit(-1);
  }
  bzero(DD, memsize);

  // memory for RR
  RRS = (long long *)malloc(memsize);
  if (RRS == NULL) {
    fprintf(stderr, "Unable to allocate memory\n");
    exit(-1);
  }
  bzero(RRS, memsize);

  // memory for DR
  DRS = (long long *)malloc(memsize);
  if (DRS == NULL) {
    fprintf(stderr, "Unable to allocate memory\n");
    exit(-1);
  }
  bzero(DRS, memsize);

  // memory for input data
  data = (struct cartesian *)malloc(args.npoints * sizeof(struct cartesian));
  if (data == NULL) {
    fprintf(stderr, "Unable to allocate memory for % data points (#1)\n",
            args.npoints);
    return (0);
  }

  random = (struct cartesian *)malloc(args.npoints * sizeof(struct cartesian));
  if (random == NULL) {
    fprintf(stderr, "Unable to allocate memory for % data points (#2)\n",
            args.npoints);
    return (0);
  }

  printf("Min distance: %f arcmin\n", min_arcmin);
  printf("Max distance: %f arcmin\n", max_arcmin);
  printf("Bins per dec: %i\n", bins_per_dec);
  printf("Total bins  : %i\n", nbins);

  // read data file
  pb_SwitchToTimer(&timers, pb_TimerID_IO);
  npd = readdatafile(params->inpFiles[0], data, args.npoints);
  pb_SwitchToTimer(&timers, pb_TimerID_COMPUTE);
  if (npd != args.npoints) {
    fprintf(stderr, "Error: read %i data points out of %i\n", npd,
            args.npoints);
    return (0);
  }

  // compute DD

  double start = omp_get_wtime();

  printf("%s=================================%s\n", blue, clear);
  printf("%sStart sequential simulation\n%s", blue, clear);

  doCompute(data, npd, NULL, 0, 1, DD, nbins, binb);

  // loop through random data files
  for (rf = 0; rf < args.random_count; rf++) {
    // read random file
    pb_SwitchToTimer(&timers, pb_TimerID_IO);
    npr = readdatafile(params->inpFiles[rf + 1], random, args.npoints);
    pb_SwitchToTimer(&timers, pb_TimerID_COMPUTE);
    if (npr != args.npoints) {
      fprintf(stderr, "Error: read %i random points out of %i in file %s\n",
              npr, args.npoints, params->inpFiles[rf + 1]);
      return (0);
    }

    // compute RR
    doCompute(random, npr, NULL, 0, 1, RRS, nbins, binb);

    // compute DR
    doCompute(data, npd, random, npr, 0, DRS, nbins, binb);
  }

  double end = omp_get_wtime();
  double seq_time = end - start;

  printf("%sTime = %lf seconds\n%s", blue, seq_time, clear);

  // compute and output results
  if ((outfile = fopen(params->outFile, "w")) == NULL) {
    fprintf(stderr,
            "Unable to open output file %s for writing, assuming stdout\n",
            params->outFile);
    outfile = stdout;
  }

  pb_SwitchToTimer(&timers, pb_TimerID_IO);
  for (k = 1; k < nbins + 1; k++) {
    fprintf(outfile, "%lld\n%lld\n%lld\n", DD[k], DRS[k], RRS[k]);
  }

  if (outfile != stdout) fclose(outfile);

  int cpu_nums[] = {2, 4, 8, 16};

  for (int i = 0; i < sizeof(cpu_nums) / sizeof(int); i++) {
    omp_set_num_threads(cpu_nums[i]);

    bzero(DD, memsize);
    bzero(RRS, memsize);
    bzero(DRS, memsize);

    printf("%s=================================%s\n", blue, clear);
    printf("%sStart simulation on %d cpus\n%s", blue, cpu_nums[i], clear);

    start = omp_get_wtime();

    doComputeParallel(data, npd, NULL, 0, 1, DD, nbins, binb);

    for (rf = 0; rf < args.random_count; rf++) {
      pb_SwitchToTimer(&timers, pb_TimerID_IO);
      npr = readdatafile(params->inpFiles[rf + 1], random, args.npoints);
      pb_SwitchToTimer(&timers, pb_TimerID_COMPUTE);
      if (npr != args.npoints) {
        fprintf(stderr, "Error: read %i random points out of %i in file %s\n",
                npr, args.npoints, params->inpFiles[rf + 1]);
        return (0);
      }

      doComputeParallel(random, npr, NULL, 0, 1, RRS, nbins, binb);

      doComputeParallel(data, npd, random, npr, 0, DRS, nbins, binb);
    }

    end = omp_get_wtime();

    double par_time = end - start;

    printf("%sTime = %lf seconds\n%s", blue, par_time, clear);
    printf("%sSpeedup = %lf\n%s", blue, seq_time / par_time, clear);

    char paroutfilename[100] = "par_";
    strcat(paroutfilename, params->outFile);
    FILE *paroutfile;

    if ((paroutfile = fopen(paroutfilename, "w")) == NULL) {
      fprintf(stderr,
              "Unable to open output file %s for writing, assuming stdout\n",
              paroutfilename);
      paroutfile = stdout;
    }

    pb_SwitchToTimer(&timers, pb_TimerID_IO);
    for (k = 1; k < nbins + 1; k++) {
      fprintf(paroutfile, "%lld\n%lld\n%lld\n", DD[k], DRS[k], RRS[k]);
    }

    if (paroutfile != stdout) fclose(paroutfile);

    if (!areFilesSame(paroutfilename, params->outFile)) {
      printf("%sTEST FAILED\n%s", red, clear);
    }
  }

  printf("%sALL TESTS PASSED\n%s", green, clear);

  // free memory
  free(data);
  free(random);
  free(binb);
  free(DD);
  free(RRS);
  free(DRS);

  pb_SwitchToTimer(&timers, pb_TimerID_NONE);
  pb_PrintTimerSet(&timers);
  pb_FreeParameters(params);
}
