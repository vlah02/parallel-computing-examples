#include <math.h>
#include <omp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/time.h>

#include "model.h"

int doCompute(struct cartesian *data1, int n1, struct cartesian *data2, int n2,
              int doSelf, long long *data_bins, int nbins, float *binb) {
  int i, j, k;
  if (doSelf) {
    n2 = n1;
    data2 = data1;
  }

  for (i = 0; i < ((doSelf) ? n1 - 1 : n1); i++) {
    const register float xi = data1[i].x;
    const register float yi = data1[i].y;
    const register float zi = data1[i].z;

    for (j = ((doSelf) ? i + 1 : 0); j < n2; j++) {
      register float dot = xi * data2[j].x + yi * data2[j].y + zi * data2[j].z;

      // run binary search
      register int min = 0;
      register int max = nbins;
      register int k, indx;

      while (max > min + 1) {
        k = (min + max) / 2;
        if (dot >= binb[k])
          max = k;
        else
          min = k;
      };

      if (dot >= binb[min]) {
        data_bins[min] += 1; /*k = min;*/
      } else if (dot < binb[max]) {
        data_bins[max + 1] += 1; /*k = max+1;*/
      } else {
        data_bins[max] += 1; /*k = max;*/
      }
    }
  }

  return 0;
}

int doComputeParallel(struct cartesian *data1, int n1, struct cartesian *data2,
                      int n2, int doSelf, long long *data_bins, int nbins,
                      float *binb) {
  int i;
  if (doSelf) {
    n2 = n1;
    data2 = data1;
  }
  int sentinel = ((doSelf) ? n1 - 1 : n1);

#pragma omp parallel
  {
    long long *local_bins = calloc(nbins + 2, sizeof(long long));
#pragma omp for schedule(dynamic) nowait
    for (i = 0; i < sentinel; i++) {
      const register float xi = data1[i].x;
      const register float yi = data1[i].y;
      const register float zi = data1[i].z;

      for (register int j = ((doSelf) ? i + 1 : 0); j < n2; j++) {
        register float dot =
            xi * data2[j].x + yi * data2[j].y + zi * data2[j].z;

        // run binary search
        register int min = 0;
        register int max = nbins;
        register int k;

        while (max > min + 1) {
          k = (min + max) / 2;
          if (dot >= binb[k])
            max = k;
          else
            min = k;
        };

        if (dot >= binb[min]) {
          local_bins[min] += 1; /*k = min;*/
        } else if (dot < binb[max]) {
          local_bins[max + 1] += 1; /*k = max+1;*/
        } else {
          local_bins[max] += 1; /*k = max;*/
        }
      }
    }

#pragma omp critical
    for (i = 0; i < nbins + 2; i++) {
      data_bins[i] += local_bins[i];
    }
  }
  return 0;
}
